<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>52dev</title>
    <description>A chinese man, detemined in Android and Python</description>
    <link>http://blog.52dev.net/</link>
    <atom:link href="http://blog.52dev.net/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 27 Mar 2016 16:52:07 +0800</pubDate>
    <lastBuildDate>Sun, 27 Mar 2016 16:52:07 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Android应用安全开发之源码安全</title>
        <description>
&lt;p&gt;本文转载自&lt;a href=&quot;http://drops.wooyun.org/mobile/12469&quot;&gt;乌云知识库-移动安全&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;Android apk很容易通过逆向工程进行反编译，从而是其代码完全暴露给攻击者，使apk面临破解，软件逻辑修改，插入恶意代码，替换广告商ID等风险。我们可以采用以下方法对apk进行保护.&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;混淆保护&lt;/h1&gt;

&lt;p&gt;混淆是一种用来隐藏程序意图的技术，可以增加代码阅读的难度，使攻击者难以全面掌控app内部实现逻辑，从而增加逆向工程和破解的难度，防止知识产权被窃取。&lt;/p&gt;

&lt;p&gt;代码混淆技术主要做了如下的工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过对代码类名，函数名做替换来实现代码混淆保护&lt;/li&gt;
  &lt;li&gt;简单的逻辑分支混淆&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;已经有很多第三方的软件可以用来混淆我们的Android应用，常见的有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Proguard&lt;/li&gt;
  &lt;li&gt;DashO&lt;/li&gt;
  &lt;li&gt;Dexguard&lt;/li&gt;
  &lt;li&gt;DexProtector&lt;/li&gt;
  &lt;li&gt;ApkProtect&lt;/li&gt;
  &lt;li&gt;Shield4j&lt;/li&gt;
  &lt;li&gt;Stringer&lt;/li&gt;
  &lt;li&gt;Allitori&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些混淆器在代码中起作用的层次是不一样的。Android编译的大致流程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Java Code(.java) -&amp;gt; Java Bytecode(.class) -&amp;gt; Dalvik 
Bytecode(classes.dex)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有的混淆器是在编译之前直接作用于java源代码，有的作用于java字节码，有的作用于Dalvik字节码。但基本都是针对java层作混淆。&lt;/p&gt;

&lt;p&gt;相对于Dalvik虚拟机层次的混淆而言，原生语言（C/C++）的代码混淆选择并不多，Obfuscator-LLVM工程是一个值得关注的例外。&lt;/p&gt;

&lt;p&gt;代码混淆的优点是使代码可阅读性变差，要全面掌控代码逻辑难度变大；可以压缩代码，使得代码大小变小。但也存在如下缺点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;无法真正保护代码不被反编译；&lt;/li&gt;
  &lt;li&gt;在应对动态调试逆向分析上无效；&lt;/li&gt;
  &lt;li&gt;通过验证本地签名的机制很容易被绕过。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说，代码混淆并不能有效的保护应用自身。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/0c23e0a886f4&quot;&gt;http://www.jianshu.com/p/0c23e0a886f4&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;二次打包防护&lt;/h1&gt;

&lt;h2 id=&quot;apk&quot;&gt;Apk签名校验&lt;/h2&gt;

&lt;p&gt;每一个软件在发布时都需要开发人员对其进行签名，而签名使用的密钥文件时开发人员所独有的，破解者通常不可能拥有相同的密钥文件，因此可以使用签名校验的方法保护apk。Android SDK中PackageManager类的getPackageInfo()方法就可以进行软件签名检测。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class getSign {
    public static int getSignature(PackageManager pm , String packageName){
    PackageInfo pi = null;
    int sig = 0;
    Signature[]s = null;
    try{
        pi = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
        s = pi.signatures;
        sig = s[0].hashCode();//s[0]是签名证书的公钥，此处获取hashcode方便对比
    }catch(Exception e){
        handleException();
    }
    return sig;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;主程序代码参考：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm = this.getPackageManager();
int s = getSign.getSignature(pm, &quot;com.hik.getsinature&quot;);
if(s != ORIGNAL_SGIN_HASHCODE){//对比当前和预埋签名的hashcode是否一致
    System.exit(1);//不一致则强制程序退出
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;dex&quot;&gt;Dex文件校验&lt;/h2&gt;

&lt;p&gt;重编译apk其实就是重编译了classes.dex文件，重编译后，生成的classes.dex文件的hash值就改变了，因此我们可以通过检测安装后classes.dex文件的hash值来判断apk是否被重打包过。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;读取应用安装目录下/data/app/xxx.apk中的classes.dex文件并计算其哈希值，将该值与软件发布时的classes.dex哈希值做比较来判断客户端是否被篡改。&lt;/li&gt;
  &lt;li&gt;读取应用安装目录下/data/app/xxx.apk中的META-INF目录下的MANIFEST.MF文件，该文件详细记录了apk包中所有文件的哈希值，因此可以读取该文件获取到classes.dex文件对应的哈希值，将该值与软件发布时的classes.dex哈希值做比较就可以判断客户端是否被篡改。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了防止被破解，软件发布时的classes.dex哈希值应该存放在服务器端。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private boolean checkcrc(){
    boolean checkResult = false;
    long crc = Long.parseLong(getString(R.string.crc));//获取字符资源中预埋的crc值
    ZipFile zf;
    try{
        String path = getApplicationContext().getPackageCodePath();//获取apk安装路径
        zf = new ZipFile(path);//将apk封装成zip对象
        ZipEntry ze = zf.getEntry(&quot;classes.dex&quot;);//获取apk中的classes.dex
        long CurrentCRC = ze.getCrc();//计算当前应用classes.dex的crc值
        if(CurrentCRC != crc){//crc值对比
            checkResult = true;
        }
    }catch(IOException e){
        handleError();
        checkResult = false;
    }
    return checkResult;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外由于逆向c/c++代码要比逆向Java代码困难很多，所以关键代码部位应该使用Native C/C++来编写。&lt;/p&gt;

&lt;h1 id=&quot;so&quot;&gt;SO保护&lt;/h1&gt;

&lt;p&gt;Android so通过C/C++代码来实现，相对于Java代码来说其反编译难度要大很多，但对于经验丰富的破解者来说，仍然是很容易的事。应用的关键性功能或算法，都会在so中实现，如果so被逆向，应用的关键性代码和算法都将会暴露。对于so的保护，可以才有编译器优化技术、剥离二进制文件等方式，还可以使用开源的so加固壳upx进行加固。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编译器优化技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了隐藏核心的算法或者其它复杂的逻辑，使用编译优化技术可以帮助混淆目标代码，使它不会很容易的被攻击者反编译，从而让攻击者对特定代码的理解变得更加困难。如使用LLVM混淆。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;剥离二进制文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;剥离本地二进制文件是一种有效的方式，使攻击者需要更多的时间和更高的技能水平来查看你的应用程序底层功能的实现。剥离二进制文件，就是将二进制文件的符号表删除，使攻击者无法轻易调试或逆向应用。在Android上可以使用GNU/Linux系统上已经使用过的技术，如sstriping或者UPX。&lt;/p&gt;

&lt;p&gt;UPX对文件进行加壳时会把软件版本等相关信息写入壳内，攻击者可以通过静态反汇编可查看到这些壳信息，进而寻找对应的脱壳机进行脱壳，使得攻击难度降低。所以我们必须在UPX源码中删除这些信息，重新编译后再进行加壳，步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用原始版本对文件进行加壳。&lt;/li&gt;
  &lt;li&gt;使用IDA反汇编加壳文件，在反汇编文件的上下文中查找UPX壳特征字符串。&lt;/li&gt;
  &lt;li&gt;在UPX源码中查找这些特征字符串，并一一删除。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://www.nowsecure.com/resources/secure-mobile-development/coding-practices/code-complexity-and-obfuscation/&quot;&gt;https://www.nowsecure.com/resources/secure-mobile-development/coding-practices/code-complexity-and-obfuscation/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;资源文件保护&lt;/h1&gt;

&lt;p&gt;如果资源文件没有保护，则会使应用存在两方面的安全风险：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过资源定位代码，方便应用破解 反编译apk获得源码，通过资源文件或者关键字符串的ID定位到关键代码位置，为逆向破解应用程序提供方便.&lt;/li&gt;
  &lt;li&gt;替换资源文件，盗版应用 “if you can see something, you can copy it”。Android应用程序中的资源，比如图片和音频文件，容易被复制和窃取。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以考虑将其作为一个二进制形式进行加密存储，然后加载，解密成字节流并把它传递到BitmapFactory。当然，这会增加代码的复杂度，并且造成轻微的性能影响。&lt;/p&gt;

&lt;p&gt;不过资源文件是全局可读的，即使不打包在apk中，而是在首次运行时下载或者需要使用时下载，不在设备中保存，但是通过网络数据包嗅探还是很容易获取到资源url地址。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;反调试技术&lt;/h1&gt;

&lt;h2 id=&quot;section-5&quot;&gt;限制调试器连接&lt;/h2&gt;

&lt;p&gt;应用程序可以通过使用特定的系统API来防止调试器附加到该进程。通过阻止调试器连接，攻击者干扰底层运行时的能力是有限的。攻击者为了从底层攻击应用程序必须首先绕过调试限制。这进一步增加了攻击复杂性。Android应用程序应该在manifest中设置&lt;code class=&quot;highlighter-rouge&quot;&gt;Android:debuggable=“false”&lt;/code&gt;，这样就不会很容易在运行时被攻击者或者恶意软件操纵。&lt;/p&gt;

&lt;h2 id=&quot;trace&quot;&gt;Trace检查&lt;/h2&gt;

&lt;p&gt;应用程序可以检测自己是否正在被调试器或其他调试工具跟踪。如果被追踪，应用程序可以执行任意数量的可能攻击响应行为，如丢弃加密密钥来保护用户数据，通知服务器管理员，或者其它类型自我保护的响应。这可以由检查进程状态标志或者使用其它技术，如比较ptrace附加的返回值，检查父进程，黑名单调试器进程列表或通过计算运行时间的差异来反调试。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/obfuscator-llvm/obfuscator/wiki&quot;&gt;https://github.com/obfuscator-llvm/obfuscator/wiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.nowsecure.com/resources/secure-mobile-development/coding-practices/code-complexity-and-obfuscation/&quot;&gt;https://www.nowsecure.com/resources/secure-mobile-development/coding-practices/code-complexity-and-obfuscation/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;a. 父进程检测
通常，我们在使用gdb调试时，是通过gdb 这种方式进行的。而这种方式是启动gdb，fork出子进程后执行目标二进制文件。因此，二进制文件的父进程即为调试器。我们可通过检查父进程名称来判断是否是由调试器fork。示例代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
  
int main(int argc, char *argv[]) {
   char buf0[32], buf1[128];
   FILE* fin;
  
   snprintf(buf0, 24, &quot;/proc/%d/cmdline&quot;, getppid());
   fin = fopen(buf0, &quot;r&quot;);
   fgets(buf1, 128, fin);
   fclose(fin);
  
   if(!strcmp(buf1, &quot;gdb&quot;)) {
       printf(&quot;Debugger detected&quot;);
       return 1;
   }  
   printf(&quot;All good&quot;);
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我们通过getppid获得父进程的PID，之后由/proc文件系统获取父进程的命令内容，并通过比较字符串检查父进程是否为gdb。实际运行结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/2016012010510132870120.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;b.当前运行进程检测&lt;/p&gt;

&lt;p&gt;例如对android_server进程检测。针对这种检测只需将android_server改名就可绕过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pid_t GetPidByName(const charchar *as_name) {  
        DIR *pdir = NULL;  
        struct dirent *pde = NULL;  
        FILEFILE *pf = NULL;  
        char buff[128];  
        pid_t pid;  
        char szName[128];  
        // 遍历/proc目录下所有pid目录    
        pdir = opendir(&quot;/proc&quot;);  
        if (!pdir) {  
                perror(&quot;open /proc fail.\n&quot;);  
                return -1;  
        }  
        while ((pde = readdir(pdir))) {  
                if ((pde-&amp;gt;d_name[0] &amp;lt; &#39;0&#39;) || (pde-&amp;gt;d_name[0] &amp;gt; &#39;9&#39;)) {  
                        continue;  
                }  
                sprintf(buff, &quot;/proc/%s/status&quot;, pde-&amp;gt;d_name);  
                pf = fopen(buff, &quot;r&quot;);  
                if (pf) {  
                        fgets(buff, sizeof(buff), pf);  
                        fclose(pf);  
                        sscanf(buff, &quot;%*s %s&quot;, szName);  
                        pid = atoi(pde-&amp;gt;d_name);  
                        if (strcmp(szName, as_name) == 0) {  
                                closedir(pdir);  
                                return pid;  
                        }  
                }  
        }  
        closedir(pdir);  
        return 0;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;c.读取进程状态(/proc/pid/status)&lt;/p&gt;

&lt;p&gt;State属性值T 表示调试状态，TracerPid 属性值正在调试此进程的pid,在非调试情况下State为S或R, TracerPid等于0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/2016012010510380203218.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此，我们便可通过检查status文件中TracerPid的值来判断是否有正在被调试。示例代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main(int argc, char *argv[]) {
   int i;
   scanf(&quot;%d&quot;, &amp;amp;i);
   char buf1[512];
   FILE* fin;
   fin = fopen(&quot;/proc/self/status&quot;, &quot;r&quot;);
   int tpid;
   const char *needle = &quot;TracerPid:&quot;;
   size_t nl = strlen(needle);
   while(fgets(buf1, 512, fin)) {
       if(!strncmp(buf1, needle, nl)) {
           sscanf(buf1, &quot;TracerPid: %d&quot;, &amp;amp;tpid);
           if(tpid != 0) {
                printf(&quot;Debuggerdetected&quot;);
                return 1;
           }
       }
    }
   fclose(fin);
   printf(&quot;All good&quot;);
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际运行结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/2016012010510789920310.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，/proc目录下包含了进程的大量信息。我们在这里是读取status文件，此外，也可通过/proc/self/stat文件来获得进程相关信息，包括运行状态。&lt;/p&gt;

&lt;p&gt;d.读取&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/%d/wchan&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下图中第一个红色框值为非调试状态值，第二个红色框值为调试状态：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/201601201051123415847.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int getWchanStatus(int pid)  
{  
      FILEFILE *fp= NULL;  
      char filename;  
      char wchaninfo = {0};  
      int result = WCHAN_ELSE;  
      char cmd = {0};  
      sprintf(cmd,&quot;cat /proc/%d/wchan&quot;,pid);  
      LOGANTI(&quot;cmd= %s&quot;,cmd);  
      FILEFILE *ptr;         
      if((ptr=popen(cmd, &quot;r&quot;)) != NULL)  
      {  
                if(fgets(wchaninfo, 128, ptr) != NULL)  
                {  
                        LOGANTI(&quot;wchaninfo= %s&quot;,wchaninfo);  
                }  
      }  
      if(strncasecmp(wchaninfo,&quot;sys_epoll\0&quot;,strlen(&quot;sys_epoll\0&quot;)) == 0)  
                result = WCHAN_RUNNING;  
      else if(strncasecmp(wchaninfo,&quot;ptrace_stop\0&quot;,strlen(&quot;ptrace_stop\0&quot;)) == 0)  
                result = WCHAN_TRACING;  
      return result;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;e.ptrace 自身或者fork子进程相互ptrace&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (ptrace(PTRACE_TRACEME, 0, 1, 0) &amp;lt; 0) {  
printf(&quot;DEBUGGING... Bye\n&quot;);  
return 1;  
}  
void anti_ptrace(void)  
{  
    pid_t child;  
    child = fork();  
    if (child)  
      wait(NULL);  
    else {  
      pid_t parent = getppid();  
      if (ptrace(PTRACE_ATTACH, parent, 0, 0) &amp;lt; 0)  
            while(1);  
      sleep(1);  
      ptrace(PTRACE_DETACH, parent, 0, 0);  
      exit(0);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;f.设置程序运行最大时间&lt;/p&gt;

&lt;p&gt;这种方法经常在CTF比赛中看到。由于程序在调试时的断点、检查修改内存等操作，运行时间往往要远大于正常运行时间。所以，一旦程序运行时间过长，便可能是由于正在被调试。&lt;/p&gt;

&lt;p&gt;具体地，在程序启动时，通过alarm设置定时，到达时则中止程序。示例代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
void alarmHandler(int sig) {
   printf(&quot;Debugger detected&quot;);
   exit(1);
}
void__attribute__((constructor))setupSig(void) {
   signal(SIGALRM, alarmHandler);
   alarm(2);
}
int main(int argc, char *argv[]) {
   printf(&quot;All good&quot;);
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在此例中，我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribute__((constructor))&lt;/code&gt;，在程序启动时便设置好定时。实际运行中，当我们使用gdb在main函数下断点，稍候片刻后继续执行时，则触发了SIGALRM，进而检测到调试器。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/201601201051141430658.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;顺便一提，这种方式可以轻易地被绕过。我们可以设置gdb对signal的处理方式，如果我们选择将SIGALRM忽略而非传递给程序，则alarmHandler便不会被执行，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/201601201051165775369.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;g.检查进程打开的filedescriptor&lt;/p&gt;

&lt;p&gt;如2.2中所说，如果被调试的进程是通过gdb 的方式启动，那么它便是由gdb进程fork得到的。而fork在调用时，父进程所拥有的fd(file descriptor)会被子进程继承。由于gdb在往往会打开多个fd，因此如果进程拥有的fd较多，则可能是继承自gdb的，即进程在被调试。&lt;/p&gt;

&lt;p&gt;具体地，进程拥有的fd会在/proc/self/fd/下列出。于是我们的示例代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
int main(int argc, char *argv[]) {
   struct dirent *dir;
   DIR *d = opendir(&quot;/proc/self/fd&quot;);
   while(dir=readdir(d)) {
       if(!strcmp(dir-&amp;gt;d_name, &quot;5&quot;)) {
           printf(&quot;Debugger detected&quot;);
           return 1;
       }
    }
   closedir(d);
   printf(&quot;All good&quot;);
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里，我们检查/proc/self/fd/中是否包含fd为5。由于fd从0开始编号，所以fd为5则说明已经打开了6个文件。如果程序正常运行则不会打开这么多，所以由此来判断是否被调试。运行结果见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/201601201051182323977.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;h.防止dump&lt;/p&gt;

&lt;p&gt;利用Inotify机制，对/proc/pid/mem和/proc/pid/pagemap文件进行监视。inotify API提供了监视文件系统的事件机制，可用于监视个体文件，或者监控目录。具体原理可参考：&lt;a href=&quot;http://man7.org/linux/man-pages/man7/inotify.7.html&quot;&gt;http://man7.org/linux/man-pages/man7/inotify.7.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;伪代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __fastcall anitInotify(int flag)  
{  
      MemorPagemap = flag;  
      charchar *pagemap = &quot;/proc/%d/pagemap&quot;;  
      charchar *mem = &quot;/proc/%d/mem&quot;;  
      pagemap_addr = (charchar *)malloc(0x100u);  
      mem_addr = (charchar *)malloc(0x100u);  
      ret = sprintf(pagemap_addr, &amp;amp;pagemap, pid_);  
      ret = sprintf(mem_addr, &amp;amp;mem, pid_);  
      if ( !MemorPagemap )  
      {  
                ret = pthread_create(&amp;amp;th, 0, (voidvoid *(*)(voidvoid *)) inotity_func, mem_addr);  
                if ( ret &amp;gt;= 0 )  
                   ret = pthread_detach(th);  
      }  
      if ( MemorPagemap == 1 )  
      {  
                ret = pthread_create(&amp;amp;newthread, 0, (voidvoid *(*)(voidvoid *)) inotity_func, pagemap_addr);  
                if(ret &amp;gt; 0)  
                  ret = pthread_detach(th);  
      }  
}  
void __fastcall __noreturn inotity_func(const charchar *inotity_file)  
{  
      const charchar *name; // r4@1  
      signed int fd; // r8@1  
      bool flag; // zf@3  
      bool ret; // nf@3  
      ssize_t length; // r10@3  
      ssize_t i; // r9@7  
      fd_set readfds; // @2  
      char event; // @1  
      name = inotity_file;  
      memset(buffer, 0, 0x400u);  
      fd = inotify_init();  
      inotify_add_watch(fd, name, 0xFFFu);  
      while ( 1 )  
      {  
                do  
                {  
                        memset(&amp;amp;readfds, 0, 0x80u);  
                }  
                while ( select(fd + 1, &amp;amp;readfds, 0, 0, 0) &amp;lt;= 0 );  
                length = read(fd, event, 0x400u);  
                flag = length == 0;  
                ret = length &amp;lt; 0;  
                if ( length &amp;gt;= 0 )  
                {  
                        if ( !ret &amp;amp;&amp;amp; !flag )  
                      {  
                              i = 0;  
                              do  
                              {  
                                        inotity_kill((int)&amp;amp;event);  
                                        i += *(_DWORD *)&amp;amp;event + 16;  
                              }  
                              while ( length &amp;gt; i );  
                        }  
                }  
                else  
                {  
                        while ( *(_DWORD *)_errno() == 4 )  
                        {  
                              length = read(fd, buffer, 0x400u);  
                              flag = length == 0;  
                              ret = length &amp;lt; 0;  
                              if ( length &amp;gt;= 0 )  
                        }  
                }  
      }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;i.对read做hook&lt;/p&gt;

&lt;p&gt;因为一般的内存dump都会调用到read函数，所以对read做内存hook，检测read数据是否在自己需要保护的空间来阻止dump&lt;/p&gt;

&lt;p&gt;j.设置单步调试陷阱&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int handler()  
{  
    return bsd_signal(5, 0);  
}  
int set_SIGTRAP()  
{  
    int result;  
    bsd_signal(5, (int)handler);  
    result = raise(5);  
    return result;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/tools/83509.html&quot;&gt;http://www.freebuf.com/tools/83509.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;应用加固技术&lt;/h1&gt;

&lt;p&gt;移动应用加固技术从产生到现在，一共经历了三代：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一代是基于类加载器的方式实现保护；&lt;/li&gt;
  &lt;li&gt;第二代是基于方法替换的方式实现保护；&lt;/li&gt;
  &lt;li&gt;第三代是基于虚拟机指令集的方式实现保护。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-7&quot;&gt;第一代加固技术：类加载器&lt;/h2&gt;

&lt;p&gt;以梆梆加固为例，类加载器主要做了如下工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;classes.dex被完整加密，放到APK的资源中&lt;/li&gt;
  &lt;li&gt;采用动态劫持虚拟机的类载入引擎的技术&lt;/li&gt;
  &lt;li&gt;虚拟机能够载入并运行加密的classes.dex&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用一代加固技术以后的apk加载流程发生了变化如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/201601201051212999186.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用启动以后，会首先启动保护代码，保护代码会启动反调试、完整性检测等机制，之后再加载真实的代码。&lt;/p&gt;

&lt;p&gt;一代加固技术的优势在于：可以完整的保护APK，支持反调试、完整性校验等。&lt;/p&gt;

&lt;p&gt;一代加固技术的缺点是加固前的classes.dex文件会被完整的导入到内存中，可以用内存dump工具直接导出未加固的classes.dex文件。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;第二代加固技术：类方法替换&lt;/h2&gt;

&lt;p&gt;第二代加固技术采用了类方法替换的技术：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将原APK中的所有方法的代码提取出来，单独加密&lt;/li&gt;
  &lt;li&gt;运行时动态劫持Dalvik虚拟机中解析方法的代码，将解密后的代码交给虚拟机执行引擎&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;采用本技术的优势为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个方法单独解密，内存中无完整的解密代码&lt;/li&gt;
  &lt;li&gt;如果某个方法没有执行，不会解密&lt;/li&gt;
  &lt;li&gt;在内存中dump代码的成本代价很高&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用二代加固技术以后，启动流程增加了一个解析函数代码的过程，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20160120/201601201051231768397.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;第三代加固技术：虚拟机指令集&lt;/h2&gt;

&lt;p&gt;第三代加固技术是基于虚拟机执行引擎替换方式，所做主要工作如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将原APK中的所有的代码采用一种自定义的指令格式进行替换&lt;/li&gt;
  &lt;li&gt;运行时动态劫持Dalvik虚拟机中执行引擎，使用自定义执行引擎执行自定义的代码&lt;/li&gt;
  &lt;li&gt;类似于PC上的VMProtect采用的技术&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三代技术的优点如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;具有2.0的所有优点&lt;/li&gt;
  &lt;li&gt;破解需要破解自定义的指令格式，复杂度非常高&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/2016/03/27/Android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E6%BA%90%E7%A0%81%E5%AE%89%E5%85%A8/</link>
        <guid isPermaLink="true">http://blog.52dev.net/2016/03/27/Android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E6%BA%90%E7%A0%81%E5%AE%89%E5%85%A8/</guid>
        
        
      </item>
    
      <item>
        <title>nginx反向代理</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;网站部署&lt;/h2&gt;
&lt;p&gt;IIS网站绑定端口801，Tomcat绑定端口8080，将nginx目录下的nginx.conf文件修改内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#user  nobody;
worker_processes  1;
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    #access_log  logs/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    keepalive_timeout  65;
    #gzip  on;
    server {
        listen       80;
        # 绑定域名
        server_name  www.guolingfa.cn;
        location / {
        	# 目标地址
       		proxy_pass   http://localhost:801;
        }
    }
	server {
        listen       80;
        server_name  guolingfa.cn;
        location / {
       		proxy_pass   http://localhost:801;
        }
    }
	server {
        listen       80;
        server_name  test.guolingfa.cn;
        location / {
       		proxy_pass   http://localhost:8080;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;nginx&quot;&gt;启动nginx&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 启动nginx 
start nginx
# 停止nginx
nginx -s stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 25 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2016/03/25/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2016/03/25/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid>
        
        <category>nginx</category>
        
        <category>tomcat</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>mac日常笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;批量转换文件编码&lt;/h2&gt;

&lt;p&gt;cd进入目标文件，执行命令将目录下所有文件转换成UTF-8编码，并保存到指定文件夹&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type f -exec bash -c &#39;iconv -f GB18030 &quot;{}&quot; 1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;&amp;amp; iconv -f GB18030 -t utf-8 &quot;{}&quot; &amp;gt; /Users/guolf/Documents/workspace/test/src/&quot;{}&quot;&#39; \; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;查找占用端口&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将端口替换成所需,将会出现占用端口进程信息(lsof -i tcp:port)
lsof -i tcp:8080
# 找到占用端口进程pid，使用kill命令杀掉该进程 kill pid
kill 1234
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;viutf-bombom&quot;&gt;使用vi将UTF bom格式转无bom格式&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:set nobomb
:wq
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;macapache&quot;&gt;mac自带Apache&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#查看版本
sudo apachectl -v
#启动
sudo apachectl start
#网站目录
open /Library/WebServer/Documents/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;添加文件可执行权限&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod a+x ./文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ntfs-3gmacntfs&quot;&gt;使用ntfs-3g实现mac的ntfs写权限&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Remove osxfuse if installed via homebrew:
&amp;gt; brew uninstall osxfuse
Install osxfuse binary and choose to install the MacFUSE compatibility layer:
http://sourceforge.net/projects/osxfuse/files/latest/download?source=files
Reboot (optional but recommended by osxfuse)
Install ntfs-3g via homebrew:
&amp;gt; brew update &amp;amp;&amp;amp; brew install ntfs-3g

or  try

brew install Caskroom/cask/osxfuse then brew install homebrew/fuse/ntfs-3g

Link mount_ntfs:
&amp;gt; sudo mv /sbin/mount_ntfs /sbin/mount_ntfs.original
&amp;gt; sudo ln -s /usr/local/Cellar/ntfs-3g/2015.3.14/sbin/mount_ntfs /sbin/mount_ntfs
The output of the following should be as below:
&amp;gt; ls -l /sbin/mount_ntfs*
/sbin/mount_ntfs -&amp;gt; /usr/local/Cellar/ntfs-3g/2014.2.15/sbin/mount_ntfs
/sbin/mount_ntfs.original -&amp;gt; /System/Library/Filesystems/ntfs.fs/Contents/Resources/mount_ntfs
Reboot and voila
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;android&quot;&gt;Android设备管家&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.airdroid.com/zh-cn/&quot;&gt;AirDroid&lt;/a&gt;是最好用的安卓设备管家，在电脑可以接收设备的通知、回复短信，电脑与设备高效互传文件，AirMirror更能实现电脑完全控制安卓设备。完美支持Mac。&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2016/03/14/mac%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2016/03/14/mac%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</guid>
        
        <category>mac</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Android日常笔记</title>
        <description>&lt;h2 id=&quot;drawableright&quot;&gt;drawableRight添加单击事件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mTelnum.setOnTouchListener(new View.OnTouchListener() {
	@Override
	public boolean onTouch(View v, MotionEvent event) {
		if(event.getAction()== MotionEvent.ACTION_UP) {
			Drawable drawableRight = ((EditText) v).getCompoundDrawables()[2];
				if (drawableRight != null &amp;amp;&amp;amp; event.getRawX() &amp;gt;= (v.getRight() - drawableRight.getBounds().width())){
					Toast.makeText(TestActivity.this, &quot;click...&quot;, Toast.LENGTH_SHORT).show();
				}
			}
			return false;
		}
});
        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;pullxml&quot;&gt;pull解析xml包含&amp;amp;会报错&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmlStr.replace(&quot;&amp;amp;&quot;,&quot;&amp;amp;amp;&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;隐藏底部虚拟导航条&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;魅族&lt;/h2&gt;
&lt;p&gt;Flyme OS 4.5.0.2Q版本运行cordova应用，点击下拉菜单会崩溃。将系统版本升级即可。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2016/02/21/Android%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2016/02/21/Android%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</guid>
        
        <category>android</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Android反编译，重新打包</title>
        <description>&lt;h2 id=&quot;android&quot;&gt;Android反编译、重新打包&lt;/h2&gt;

&lt;h3 id=&quot;apktool&quot;&gt;安装apktool&lt;/h3&gt;

&lt;p&gt;参考&lt;a href=&quot;http://ibotpeaches.github.io/Apktool/install/&quot;&gt;http://ibotpeaches.github.io/Apktool/install/&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 反编译
$ apktool d testapp.apk
I: Using Apktool 2.0.0 on testapp.apk
I: Loading resource table...
I: Decoding AndroidManifest.xml with resources...
I: Loading resource table from file: 1.apk
I: Regular manifest package...
I: Decoding file-resources...
I: Decoding values */* XMLs...
I: Baksmaling classes.dex...
I: Copying assets and libs...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 反编译修改后重新打包
$ apktool b test
I: Using Apktool 2.0.1 on test
I: Checking whether sources has changed...
I: Smaling smali folder into classes.dex...
I: Checking whether resources has changed...
I: Building resources...
I: Building apk file...
I: Copying unknown files/dir..
# 重新签名
$ jarsigner -keystore /Users/guolf/.android/debug.keystore 
-storepass android -keypass android test.apk androiddebugkey 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;dex2jar&quot;&gt;安装dex2jar&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;下载安装文件&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://sourceforge.net/projects/dex2jar/files/&quot;&gt;https://sourceforge.net/projects/dex2jar/files/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;解压到指定位置&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unzip -x dex2jar-version.zip -d /home/username
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;反编译&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将apk反编译成.jar文件，然后可使用jd-gui打开
sh /home/username/dex2jar-2.0/d2j-dex2jar.sh /home/username/someApk.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用jd-gui查看源码，下载地址&lt;a href=&quot;http://jd.benow.ca/&quot;&gt;http://jd.benow.ca/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2015/12/19/android%E5%8F%8D%E7%BC%96%E8%AF%91-%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2015/12/19/android%E5%8F%8D%E7%BC%96%E8%AF%91-%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85/</guid>
        
        <category>android</category>
        
        <category>apktool</category>
        
        <category>dex2jar</category>
        
        <category>jd-gui</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>linux利用ssh key 免密码登陆</title>
        <description>&lt;h2 id=&quot;ssh-keylinux&quot;&gt;利用ssh key验证登陆Linux服务器&lt;/h2&gt;
&lt;p&gt;### 生成SSH Key&lt;/p&gt;

&lt;h4 id=&quot;rsa-key-pair&quot;&gt;创建RSA Key Pair&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;key&quot;&gt;输入key保存位置&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enter file in which to save the key (/home/demo/.ssh/id_rsa):
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enter passphrase (empty for no passphrase):
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/demo/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/demo/.ssh/id_rsa.
Your public key has been saved in /home/demo/.ssh/id_rsa.pub.
The key fingerprint is:
4a:dd:0a:c6:35:4e:3f:ed:27:38:8c:74:44:4d:93:67 demo@a
The key&#39;s randomart image is:
+--[ RSA 2048]----+
|          .oo.   |
|         .  o.E  |
|        + .  o   |
|     . = = .     |
|      = S = .    |
|     o + = +     |
|      . o + o .  |
|           . o   |
|                 |
+-----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;#### 将生成的id_rsa.pub拷贝到服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scp -p 1234 /home/demo/.ssh/id_rsa.pub root@server:/root/.ssh/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将id_rsa.pub重命名成authorized_keys&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd .ssh
mv id_rsa.pub authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;#### 修改本机的ssh config
config文件位于&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/config&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host myvps
Hostname 104.XX.XXX.XX
Port 1234
User root
IdentityFile ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后直接 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh myvps&lt;/code&gt; 即可连接上远程服务器。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2015/08/26/ssh-key-login/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2015/08/26/ssh-key-login/</guid>
        
        <category>linux</category>
        
        <category>ssh</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>AOP框架Dexposed使用详解</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;典型的使用场景&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;AOP编程&lt;/li&gt;
  &lt;li&gt;插桩（例如测试，性能监控等）&lt;/li&gt;
  &lt;li&gt;在线热更新，修复严重的，紧急的或者安全性的bug&lt;/li&gt;
  &lt;li&gt;SDK hooking以提供更好的开发体验&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何集成&lt;/h2&gt;

&lt;p&gt;集成方式很简单，直接dexposed aar添加到您的项目作为编译库，它包含了从“dexposed”目录中的jar文件“dexposedbridge.jar”和两个so文件“libdexposed.so libdexposed_l.so”。Gradle依赖如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dependencies {
	compile &#39;com.taobao.android:dexposed:0.1.1@aar&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在应用启动时进行初始化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyApplication extends Application {

	private boolean mIsSupported = false; // 设备是否支持dexposed
    private boolean mIsLDevice = false;  // 设备Android系统是否是Android 5.0及以上

    @Override public void onCreate() {    
     super.onCreate();    
        // Check whether current device is supported (also initialize Dexposed framework if not yet)
        mIsSupported = DexposedBridge.canDexposed(this);
    	mIsLDevice = Build.VERSION.SDK_INT &amp;gt;= 21;
    }
    public boolean isSupported() {
    return mIsSupported;
	}

    public boolean isLDevice() {
        return mIsLDevice;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;基本用法&lt;/h2&gt;

&lt;p&gt;对于某个函数而言，有三个注入点可供选择：函数执行前注入（before），函数执行后注入（after），替换函数执行的代码段（replace）。
例子1：应用中所有的Activity.onCreate(Bundle)函数调用之前和之后增加一些相同的处理：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Target class, method with parameter types, followed by the hook callback (XC_MethodHook).
DexposedBridge.findAndHookMethod(Activity.class, &quot;onCreate&quot;, Bundle.class, new XC_MethodHook() {

    // To be invoked before Activity.onCreate().
    @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            // &quot;thisObject&quot; keeps the reference to the instance of target class.
            Activity instance = (Activity) param.thisObject;

            // The array args include all the parameters.
            Bundle bundle = (Bundle) param.args[0];
            Intent intent = new Intent();
            // XposedHelpers provide useful utility methods.
            XposedHelpers.setObjectField(param.thisObject, &quot;mIntent&quot;, intent);

            // Calling setResult() will bypass the original method body use the result as method return value directly.
            if (bundle.containsKey(&quot;return&quot;))
                param.setResult(null);
        }

        // To be invoked after Activity.onCreate()
        @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable {
            XposedHelpers.callMethod(param.thisObject, &quot;sampleMethod&quot;, 2);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例子2：在线热更新
我们假设宿主apk的MainActivity.showDialog函数出现问题，需要打补丁，宿主代码如下所示：（类完整路径是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.taobao.dexposed;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.TextView;

import com.taobao.android.dexposed.XC_MethodHook;
import com.taobao.android.dexposed.DexposedBridge;
import com.taobao.patch.PatchMain;
import com.taobao.patch.PatchResult;

import java.io.File;


public class MainActivity extends Activity {

	private boolean isSupport = false;

    private boolean isLDevice= false;
	
	private TextView mLogContent;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		mLogContent = (TextView) (this.findViewById(R.id.log_content));
		// check device if support and auto load libs
        isSupport = DexposedBridge.canDexposed(this);
        isLDevice = android.os.Build.VERSION.SDK_INT == 21;
	}

	//Hook system log click
	public void hookSystemLog(View view) {
		if (isSupport) {
			DexposedBridge.findAndHookMethod(isLDevice ? this.getClass(): Log.class, isLDevice ? &quot;showLog&quot; : &quot;d&quot;, String.class, String.class, new XC_MethodHook() {
				@Override
				protected void afterHookedMethod(MethodHookParam arg0) throws Throwable {
					String tag = (String) arg0.args[0];
					String msg = (String) arg0.args[1];
					mLogContent.setText(tag + &quot;,&quot; + msg);
				}
			});
            if (isLDevice) {
                showLog(&quot;dexposed&quot;, &quot;It doesn&#39;t support AOP to system method on ART devices&quot;);
            } else {
                Log.d(&quot;dexposed&quot;, &quot;Logs are redirected to display here&quot;);
            }
		} else {
			mLogContent.setText(&quot;This device doesn&#39;t support dexposed!&quot;);
		}
	}

    private void showLog(String tag, String msg) {
        Log.d(tag, msg);
    }
	
	// Hook choreographer click
	public void hookChoreographer(View view) {
		Log.d(&quot;dexposed&quot;, &quot;hookChoreographer button clicked.&quot;);
		if (isSupport &amp;amp;&amp;amp; !isLDevice) {
			ChoreographerHook.instance().start();
		} else {
			showLog(&quot;dexposed&quot;, &quot;This device doesn&#39;t support this!&quot;);
		}
	}
	
	// Run patch apk
	public void runPatchApk(View view) {
		Log.d(&quot;dexposed&quot;, &quot;runPatchApk button clicked.&quot;);
        if (isLDevice) {
            showLog(&quot;dexposed&quot;, &quot;It doesn&#39;t support this function on L device.&quot;);
            return;
        }
        if (!isSupport) {
			Log.d(&quot;dexposed&quot;, &quot;This device doesn&#39;t support dexposed!&quot;);
			return;
		}
		File cacheDir = getExternalCacheDir();
    	if(cacheDir != null){
    		String fullpath = cacheDir.getAbsolutePath() + File.separator + &quot;patch.apk&quot;;
    		PatchResult result = PatchMain.load(this, fullpath, null);
    		if (result.isSuccess()) {
    			Log.e(&quot;Hotpatch&quot;, &quot;patch success!&quot;);
    		} else {
    			Log.e(&quot;Hotpatch&quot;, &quot;patch error is &quot; + result.getErrorInfo());
    		}
    	}
    	showDialog();
	}
	
	private void showDialog() {
		AlertDialog.Builder builder = new AlertDialog.Builder(this);
		builder.setTitle(&quot;Dexposed sample&quot;)
				.setMessage(
						&quot;Please clone patchsample project to generate apk, and copy it to \&quot;/Android/data/com.taobao.dexposed/cache/patch.apk\&quot;&quot;)
				.setPositiveButton(&quot;ok&quot;, new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface dialog, int whichButton) {
					}
				}).create().show();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;补丁apk只有一个名为DialogPatch的类，实现了patchloader函数库中的IPatch接口，IPatch接口代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.taobao.patch;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;

import com.taobao.android.dexposed.XC_MethodReplacement;
import com.taobao.android.dexposed.DexposedBridge;

public class DialogPatch implements IPatch {

	@Override
	public void handlePatch(final PatchParam arg0) throws Throwable {    	
    	Class&amp;lt;?&amp;gt; cls = null;
		try {
			cls= arg0.context.getClassLoader()
					.loadClass(&quot;com.taobao.dexposed.MainActivity&quot;);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
			return;
		}     	
     	DexposedBridge.findAndHookMethod(cls, &quot;showDialog&quot;,
				new XC_MethodReplacement() {
			@Override
			protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
				Activity mainActivity = (Activity) param.thisObject;
				AlertDialog.Builder builder = new AlertDialog.Builder(mainActivity);
				builder.setTitle(&quot;Dexposed sample&quot;)
						.setMessage(&quot;The dialog is shown from patch apk!&quot;)
						.setPositiveButton(&quot;ok&quot;, new DialogInterface.OnClickListener() {
							public void onClick(DialogInterface dialog, int whichButton) {
							}
						}).create().show();
				return null;                 
			}
		});
	} 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将补丁打包成apk,通过adb push到/Android/data/com.taobao.dexposed/cache/patch.apk,点击runPatchApk即可看到弹出的内容为补丁的内容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb push patch.apk /sdcard/Android/data/com.taobao.dexposed/cache/patch.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;支持的版本&lt;/h2&gt;

&lt;p&gt;Dexposed支持从Android2.3到4.4（除了3.0）的所有dalvid运行时arm架构的设备，稳定性已经经过实践检验。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Runtime&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Android Version&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Support&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Dalvik&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Not Test&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dalvik&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dalvik&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dalvik&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.0-4.4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ART&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Testing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ART&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ART&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;M&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;No&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-4&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/dexposed&quot;&gt;dexposed&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2015/08/26/AOP%E6%A1%86%E6%9E%B6Dexposed%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2015/08/26/AOP%E6%A1%86%E6%9E%B6Dexposed%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>android</category>
        
        <category>aop</category>
        
        <category>dexposed</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>利用Github + Jekyll 搭建个人博客</title>
        <description>&lt;h2 id=&quot;github--jekyll-&quot;&gt;利用Github + Jekyll 搭建个人博客&lt;/h2&gt;

&lt;p&gt;我写这篇文章的目的是记录本博客的搭建过程，自己从零开始逐步搭建起来了GitHub Pages，其中借鉴了很多的博客和模版，稍后会在后面列出，也为没有用过gihub和jekyll的童鞋提供一点帮助。&lt;/p&gt;

&lt;p&gt;学习使用github网页的最好办法就是clone别人的代码，看懂他们的代码，并修改成自己喜欢的样子。这篇文章介绍了windows下从最初安装软件到使用的过程。&lt;/p&gt;

&lt;p&gt;下面开始一步步讲解Github Pages的使用流程：&lt;/p&gt;

&lt;h2 id=&quot;windowsruby&quot;&gt;在windows下安装ruby环境&lt;/h2&gt;

&lt;h3 id=&quot;rubyinstaller-for-windowshttprubyinstallerorgdownloads&quot;&gt;1). 下载并安装 &lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;RubyInstaller for Windows&lt;/a&gt;。&lt;/h3&gt;
&lt;p&gt;版本可以选择2.0或者1.9.3都可以。&lt;/p&gt;

&lt;p&gt;双击安装，安装时选中“Add Ruby executables to your PATH”前的框将ruby添加到环境变量中。&lt;/p&gt;

&lt;p&gt;安装完成后，在 Windows 命令行窗口中执行以下命令，检查ruby是否已经加到PATH中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruby --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;devkit-&quot;&gt;2). 安装 DevKit 。&lt;/h3&gt;

&lt;p&gt;请根据主页上的描述下载对应的DevKit版本，下载后直接解压到没有空格的路径（例如 E:\DevKit)，然后在Windows的命令行窗口中执行以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruby dk.rb init 
ruby dk.rb install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;3). 安装Jekyll和相关的包。&lt;/h3&gt;

&lt;p&gt;由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。解决方案是使用淘宝的 RubyGems 镜像，它是一个完整 rubygems.org 镜像，你可以用此代替官方版本，同步频率目前为15分钟一次以保证尽量与官方服务同步。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem sources --remove https://rubygems.org/
gem sources -a https://ruby.taobao.org/
gem sources -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完成Ruby和DevKit 后继续安装jekyll，执行如下命令安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等待安装完成即可。&lt;/p&gt;

&lt;h2 id=&quot;git&quot;&gt;创建git版本库&lt;/h2&gt;

&lt;p&gt;登录到自己的Github账户，选择New repository，Project Name命名为：”你的用户名”.github.com，例如我的就叫“guolf.github.com”。&lt;/p&gt;

&lt;p&gt;完成后在本地克隆jekyll-bootstrap模版，运行命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将jekyll-bootstrap模版克隆到本地USERNAME.github.com文件夹下。&lt;/p&gt;

&lt;p&gt;然后cd到文件夹内运行命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;jekyll&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serve&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;成功后打开浏览器输入地址：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000&lt;/code&gt; 即可浏览本地生成的页面。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;绑定域名&lt;/h2&gt;

&lt;p&gt;创建CNAME文件，内容是你的域名。比如： guolf.com
登录域名DNS解析页面，如果是绑定顶级域名，则增加一条A记录，指向[username].github.io所对应的IP。可通过ping命令获得。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Users\User&amp;gt;ping guolf.github.io
正在 Ping github.map.fastly.net [103.245.222.133] 具有 32 字节的数据:
来自 103.245.222.133 的回复: 字节=32 时间=64ms TTL=49
来自 103.245.222.133 的回复: 字节=32 时间=65ms TTL=49
来自 103.245.222.133 的回复: 字节=32 时间=63ms TTL=49
来自 103.245.222.133 的回复: 字节=32 时间=63ms TTL=49
103.245.222.133 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 63ms，最长 = 65ms，平均 = 63ms
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过上述可得知，guolf.github.io所对应的Ip为103.245.222.133。&lt;/p&gt;

&lt;p&gt;增加两条A记录，@、WWW  均指向103.245.222.133&lt;/p&gt;

&lt;p&gt;如果是二级域名，通过增加解析CNAME记录.
CNAME文件内容为blog.52dev.net
增加一条CNAME记录，主机记录填写blog,记录值填写&lt;code class=&quot;highlighter-rouge&quot;&gt;guolf.github.io&lt;/code&gt;即可。&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Feb 2015 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2015/02/03/%E5%88%A9%E7%94%A8Github-+-Jekyll-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2015/02/03/%E5%88%A9%E7%94%A8Github-+-Jekyll-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        
        <category>github</category>
        
        <category>jekyll</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>ssh文件上传下载</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;下载文件和目录&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 从服务下载文件
scp username@servername:/remote/filename /local/dir/
# 从服务器下载整个目录
scp -r username@servername:/remote/dir/ /local/dir/
# 非默认端口下载文件
scp -P 29308 username@servername:/remote/filename /local/dir/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;上传文件和目录&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 上传指定文件到服务器
scp /local/filename username@servername:/remote/dir
# 上传目录到服务器
scp  -r /local/dir username@servername:/remote/dir
# 非默认端口上传文件
scp -P 13122 /local/filename username@servername:/remote/dir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;仅作记录.&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://blog.52dev.net/blog/2014/11/21/ssh-upload-download-file/</link>
        <guid isPermaLink="true">http://blog.52dev.net/blog/2014/11/21/ssh-upload-download-file/</guid>
        
        <category>linux</category>
        
        <category>ssh</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
