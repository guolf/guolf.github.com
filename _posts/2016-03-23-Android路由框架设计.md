---
layout: post
title: Android路由框架设计与实现
date: 2016-3-23
categories: blog
author: beautifulSoup
tags: [Android, Development]
description: 本篇文章主要介绍AndRouter，基于Android的路由框架。

---
# 背景
我们知道传统的网站开发框架一般支持用户设置路由表，如Django。而在Android开发中，我们打开页面的方式主要是startActivity()。使用startActivity()的缺点是需要打开的那个Activity的类已经存在，否则无法通过编译，但是在协同开发中，这往往是无法得到满足的。那么如何来解决这一问题呢，我们是否也能够像在Web开放中一样使用一个url来打开一个Activity呢？因此本文主要介绍在Android平台设计和实现一个路由框架。

# 框架整体设计
首先我们需要明确一点，那就是我们的框架不能仅仅局限于打开Activity，打开Activity只是框架中的一种行为实现，我们的框架应该是包含了Activity以及其它比较常用的路由。并支持使用者自己添加自己的路由实现的，如使用者希望使用url调用一个方法，或者调用一个Runnable，那么他就可以自己实现一个Router来支持这种行为。基于这样的思路，路由框架的整体架构设计如下。
![路由框架设计](https://img.alicdn.com/imgextra/i2/754328530/TB2XFdcepXXXXX5XXXXXXXXXXXX-754328530.jpg)

在以上框架中，由RouterManager维护所有的IRouter列表。我们的框架自身实现了打开Activity的ActivityRouter。同时用户可以添加自己的IRouter实现。当用户想要打开某个url时，调用RouterManager的open()方法，RouterManager遍历列表，调用IRouter的canOpenTheUrl方法找到第一个能够打开该url的IRouter，并将该open的任务dispatch给该Router。
但是在分析实际使用情景中，我们发现这样的框架设计并不能满足实际使用需求，主要有如下几点。
 
 - 在打开Activity可能需要设置动画。
 - 需要选择使用startActivityForResult()来打开Activity。
 - 需要传递一些无法放到url中的传递参数，如Parcelable等。

虽然这仅仅是ActivityRouter的需求，但我们也需要让我们的框架支持这些。
因此，我们对以上框架设计做了一些修改如下。
![路由框架设计修改版](https://img.alicdn.com/imgextra/i1/754328530/TB20x_2epXXXXapXpXXXXXXXXXX-754328530.jpg)
用户在需要额外设置一些参数的时候可以不选择使用open打开url，而是使用getRoute()方法获得抽象的Route对象，通过Route对象进行额外的设置，最后可以通过IRoute接口的open方法打开它自己。IRouter和IRoute的关系应该是一对一或者一对多，一种IRouter应该可以打开一或者多种不同IRoute。而一个IRoute则一般只能由一种IRouter打开。

# 路由格式
在路由框架中，url应该包含两点功能，一是唯一确定一条路由，二是提供一些参数。我们可以以一个路由的例子来讲解ActivityRouter的路由规则。本规则参考了REST。   
例：activity://main/:i{key1}/path1/:f{key2}

 - scheme为activity代表该url可以被ActivityRouter打开。
 - host为main一般表示决定的Activity。
 - 而:{key1}则表示一个值的key，这个path segment在url中会被具体的值替换，:后面的i表示该key对应的值的类型为int型。
 - path1为固定的path segment，与上面的key用来传递值不同。用来区分路由，与host功能类似。

因此一个url与路由匹配需要scheme，host以及path中的固定部分相同，而key部分被具体的值代替。以下举一个匹配上面的路由的url的例子。
activity:main/123/path1/12.4。则会调用intent的putExtra()方法将key1=123, key2=12.4放到intent的bundle中。在被跳的Activity中就可以获取对应的值。如果有些值是不必须的，已可以放到query parameter中。如activity://main/123/path1?des=hello。但query parameter不影响路由匹配。
以上只是我实现的ActivityRouter的路由格式，如果你需要实现自己的路由，完全可以根据自己的想法设计路由格式。

### 路由表的初始化
Router需要提供一个方法让使用者初始化路由表。如下ActivityRouter的实现，当然这并不必要，如打开网页的Router就不需要路由表，只需要调用系统浏览器打开网页即可。所以该方法没有在接口中定义。

```java
	public void init(Context appContext, IActivityRouteTableInitializer initializer) {
        mBaseContext = appContext;
        initializer.initRouterTable(mRouteTable);
    }
```

```java
public interface IActivityRouteTableInitializer {
    /**
     * init the router table
     * @param router the router map to
     */
    void initRouterTable(Map<String, Class<? extends Activity>> router);
}
```

# 总结
我们发现将原本startActivity方式替换成路由方式后，有以下几个明显的优点。

- 便于协同开发
- 便于测试，可以在测试中替换一个路由表，打开测试用Activity。
- 便于从外部链接跳转到app中的任意界面。我们只需要设置一个外链入口Activity，让其接收外部链接，并调用路由管理器打开该链接即可。

# 项目地址
[https://github.com/campusappcn/AndRouter](https://github.com/campusappcn/AndRouter)